{"name":"Traducciones","tagline":"artículos varios traducidos de diversas fuentes","body":"# Automatización de tareas con Gulp\r\n* [Texto original](http://www.smashingmagazine.com/2014/06/11/building-with-gulp/)\r\n* [Gulp.js en Github](https://github.com/gulpjs/gulp/blob/master/docs/API.md)\r\n* [Flujo de trabajo con Gulp.js](http://maximilianschmitt.me/posts/gulp-js-tutorial-sass-browserify-jade/)\r\n* [Gulp.js y Bootstrapp 3](http://stackoverflow.com/questions/21994582/using-gulp-to-compile-bootstrap-less-files-into-main-bootstrap-cs)\r\n\r\n## Contenido\r\n* [¿Que es Gulp?](#que-es-gulp)\r\n\r\n* [Instalar Gulp](#instalar-gulp)\r\n\r\n* [Uso de Gulp](#uso-de-gulp)\r\n\r\n* [Canales de procesos](#canales-de-procesos)\r\n\r\n* [gulp.src](#gulp.src)\r\n\r\n* [Definición de tareas](#definicion-de-tareas)\r\n\r\n* [Tareas por defecto](#tareas-por-defecto)\r\n\r\n* [Complementos](#complementos)\r\n\r\n* [El complemento gulp-load-plugins](#el-complemento-gulp-load-plugins)\r\n\r\n* [Seguimiento de archivos](#seguimiento-de-archivos)\r\n\r\n* [Recarga de cambios en el navegador](#recarga-de-cambios-en-el-navegador)\r\n\r\n* [¿Por que Gulp?](#¿por-que-gulp?)\r\n\r\nLa optimización de los recursos web y la comprobación del funcionamiento de la página en diferentes navegadores no son la parte más divertida del proceso de diseño. Por suerte, se trata de un conjunto de tareas repetitivas que pueden ser automatizadas con las herramientas adecuadas para así aumentar tu eficiencia.\r\n\r\nGulp es un sistema de montaje que puede mejorar tu desarrollo de páginas web mediante la automatización tareas comunes, como la compilación del CSS pre-procesado, la minimización de Javascript y la recarga del navegador. En este artículo, veremos como puedes usar Gulp para cambiar tu flujo de trabajo de desarrollo, haciéndolo más rápido y más eficiente. \r\n\r\n## ¿Que es Gulp?\r\nGulp es un sistema de montaje, lo que significa que puedes usarlo para automatizar tareas corrientes en el desarrollo de páginas web. Está montado sobre Node.js y tanto el código fuente de Gulp, como tu archivo Gulp, en el que se definen las tareas, está escritos en Javascript (o si lo prefieres, en CoffeScript o algo parecido). Esto lo hace perfecto para los desarrolladores front-end: puedes crear tareas para limpiar tu Javascript y tu CSS, interpretar tus plantillas y compilar tu LESS cuando cambia algún archivo (estos solo son algunos ejemplos), y todo ello en un lenguaje que te es familiar.\r\n\r\nGulp por si mismo no hace en realidad gran cosa, pero existe un número ingente de complementos -plugins- que puedes encontrar en la [página de complementos](http://gulpjs.com/plugins) o efectuando una búsqueda `gulpplugin` usando `npm`. Hay, por ejemplo, complementos para [ejecutar JSHint](https://www.npmjs.org/package/gulp-jshint/), para [compilar CoffeeScript](https://www.npmjs.org/package/gulp-coffee/), para [ejecutar test con Mocha](http://npmjs.org/package/gulp-mocha) o incluso para [actualizar el número de tu versión](http://npmjs.org/package/gulp-bump).\r\n\r\nExisten otras herramientas de montaje, como [Grunt](http://gruntjs.com/), o más recientemente, [Broccoli](http://www.solitr.com/blog/2014/02/broccoli-first-release/), pero considero que Gulp es superior (vease la sección [¿Por que Gulp?](#--por-que-gulp--). He reunido una larga [lista de herramientas de montaje escritas con Javascript](https://gist.github.com/callumacrae/9231589). \r\nGulp es código libre y lo puedes encontrar en [Github](https://github.com/gulpjs/gulp/).\r\n\r\n## Instalar Gulp\r\nInstalar Gulp es realmente fácil. Primero instala el paquete de Gulp globalmente:\r\n```shell\r\n$ npm install -g gulp\r\n```\r\nLuego instálalo en tu proyecto (como dependencia para el desarrollo):\r\n```shell\r\n$ npm install --save-dev gulp\r\n```\r\n## Uso de Gulp\r\n\r\nVamos a crear una tarea en Gulp para minimizar uno de nuestros archivos Javascript.\r\n1. Crea un archivo `gulpfile.js`. En este es en el que definirás tus tareas Gulp, que se ejecutarán mediante la orden `gulp`.\r\n2. Incluye lo siguiente en este archivo `gulpfile.js`:\r\n\r\n```javascript\r\nvar gulp = require(\"gulp\"),\r\n  uglify = require(\"gulp-uglify\");\r\n\r\ngulp.task(\"minify\", function () {\r\n  gulp.src(\"js/app.js\")\r\n    .pipe(uglify())\r\n    .pipe(gulp.dest(\"build\"));\r\n});\r\n```\r\n3. Instala `gulp-uglify` usando `npm`:\r\n[UglifyJS](https://github.com/mishoo/UglifyJS) – un intérprete, compresor y embellecedor para JavaScript\r\n\r\n```shell\r\n$ npm install --save-dev gulp-uglify\r\n$ gulp minify\r\n```\r\n\r\nSuponiendo que hubiera un archivo `app.js` en el directorio `js` se creará un nuevo archivo `app.js` en el directorio de montaje con el contenido minimizado de `js/app.js`.\r\n\r\n¿Que es lo que ha pasado? En el archivo `gulpfile.js` hacemos varias cosas. Primero cargamos los módulos `gulp` y `gulp-uglify`:\r\n\r\n```javascript\r\nvar gulp = require(\"gulp\"),\r\n  uglify = require(\"gulp-uglify\");\r\n```\r\nA continuación definimos una tarea que llamamos `minify` que al ejecutarse llamará la función incluida como segundo parámetro:\r\n```javascript\r\ngulp.task(\"minify\", function () {\r\n  // ...\r\n});\r\n```\r\nFinalmente, y aquí es donde se complica la cosa, definimos lo que deben hacer nuestras tareas:\r\n```javascript\r\ngulp.src(\"js/app.js\")\r\n  .pipe(uglify())\r\n  .pipe(gulp.dest(\"build\"));\r\n```\r\nA menos que estés familiarizado con las `streams` -canal de procesos-, que no suele ser el caso con los desarrolladores front-end, el código anterior no significará gran cosa.\r\n\r\n## Canales de procesos\r\nLos canales de procesos te capacitan para enviar una serie de datos a través de un conjunto de funciones, en general pequeñas, que  modifican los datos y luego los pasan a la siguiente función.\r\n\r\nEn el ejemplo anterior, la función `gulp.src()` toma una cadena con la que coincide un archivo o varios (conocidos como un \"glob\") y crea una corriente de objetos que representan a esos archivos. Luego estos son canalizados hacia la función `uglify()`, la cual toma los objetos archivo y devuelve nuevos objetos archivo con el código minimizado. Esta salida se canaliza hacia la función `gulp.dest()`, que guarda los archivos modificados.\r\n\r\nCuando solo hay una tarea que ejecutar la función no hace gran cosa. De todas maneras, considera el código siguiente:\r\n```javascript\r\ngulp.task(\"js\", function () {\r\n  return gulp.src(\"js/*.js\")\r\n    .pipe(jshint())\r\n    .pipe(jshinr.reporter(\"default\"))\r\n    .pipe(uglify())\r\n    .pipe(concat(\"app.js\"))\r\n    .pipe(gulp.dest(\"build\"));\r\n});\r\n```\r\nPara ejecutarlo por ti mismo, instala `gulp`, `gulp-jshint`, `gulp-uglify` y `gulp-concat`.\r\n\r\nEsta tarea cogerá todos los archivos que coincidan con `js/*.js` (es decir, todos los archivos Javascript del directorio `js`), ejecutará JSHint sobre ellos e imprimirá el resultado, ejecutará `uglify` sobre cada uno de ellos y luego los concatenará (en un único archivo) alojándolos en `build/app.js`.\r\n\r\nSi estás familiarizado con Grunt, verás que esto es bastante diferente de como lo hace Grunt. Grunt no usa canales de procesos -streams-; en su lugar, toma archivos, ejecuta tareas individuales sobre ellos y los guarda como nuevos archivos, repitiendo el proceso para cada tarea. Esto resulta en un montón de accesos al sistema de archivos, haciéndolo más lento que Gulp.\r\n\r\nPara una lectura más pormenorizada sobre canales de procesos -streams-, écha un vistazo a [Stream Handbook](https://github.com/substack/stream-handbook).\r\n\r\n## gulp.src\r\nLa función `gulp.src()` usa un `glob` -literalmente, pegote- (es decir, una cadena que coincide con uno o más archivos) o un vector de pegotes y devuelve un canal de procesos que puede canalizarse hacia los complementos -plugins-.\r\n\r\nGulp usa [node-glob](https://github.com/isaacs/node-glob) para obtener los archivos a partir del pegote o pegotes que has indicado. Lo más fácil es usar un ejemplo para explicarlo:\r\n* `js/app.js`\r\n\r\nApunta al archivo exacto\r\n* `js/*.js`\r\n\r\nApunta a todos los archivos con extensión `.js` solo en el directorio `js/`\r\n* `js/**/*.js`\r\n\r\nApunta a todos los archivos con extensión `.js` en el directorio `js/` y en todos sus subdirectorios\r\n* `!js/app.js`\r\n\r\nExcluye a `js/app.js`de la coincidencia, lo cual resulta útil cuando deseas hallar coincidencia con todos los archivos de un directorio excepto con uno en particular.\r\n* `*.+(js|css)`\r\n\r\nApunta a todos los archivos en el directorio raiz que terminen en `.js` o `css`.\r\n\r\nHay más posibilidades, pero no se suelen usar comúnmente en Gulp. Echa un vistazo a la documentación de [Minimatch](https://github.com/isaacs/minimatch) para descubrirlas.\r\n\r\nDigamos que tenemos un directorio de nombre `js` que contiene archivos Javascript, unos minimizados y otros no, y que queremos crear una tarea que minimice los archivos que aún no lo están. Para ello, apuntamos a todos los archivos Javascript en el directorio y excluimos luego a todos los archivos con extensión `.min.js`:\r\n```javascript\r\ngulp.src([\"js/**/*.js\", \"!js/**/*.min.js\"])\r\n```\r\n\r\n## Definición de tareas\r\nPara definir una tarea usa la función `gulp.task()`. Cuando defines una tarea sencilla, esta función toma dos argumentos: el nombre de la tarea y la función a ejecutar.\r\n```javascript\r\ngulp.task(\"saludo\", function () {\r\n  console.log(\"¡Hola mundo!\");\r\n});\r\n```\r\n\r\nLa ejecución de `gulp saludo` resulta en la impresión de \"¡Hola mundo!\" en la consola.\r\n\r\nUna tarea puede ser una lista de otras tareas. Supongamos que queremos definir una tarea de montaje que ejecute otras tres tareas `css`, `js` e `ìmgs`. Podemos hacerlo especificando un vector de tareas en lugar de la función:\r\n```javascript\r\ngulp.task(\"build\", [\"css\", \"js\", \"imgs\"]);\r\n```\r\nEstas se ejecutarán asíncronamente, por lo que no puedes suponer que la ejecución de la tarea `css` ha concluido cuando empieza `js` -de hecho lo más probable es que no sea así. Para garantizarnos que una tarea ha concluido antes de que empiece la siguiente, puedes especificar las dependencias mediante la combinación del vector de tareas con la función. Por ejemplo, para definir una tarea `css` que comprueba que la tarea `greet` ha terminado de ejecutarse antes de empezar, puedes hacer esto:\r\n\r\n```javascript\r\ngulp.task(\"css\", [\"greet\"], function () {\r\n  // Procesamiento de `css`\r\n});\r\n```\r\n\r\nAhora, cuando ejecutas la tarea `css`, Gulp ejecutará la tarea `greet`, esperará a que termine y después llamará a la función que hayas especificado.\r\n\r\n## Tareas por defecto\r\nPuedes definir una tarea por defecto que se ejecuta cuando ejecutas simplemente `gulp`. Puedes hacerlo definiendo una tarea a la que denomines `default`.\r\n```javascript\r\ngulp.task(\"default\", function () {\r\n  // Tu tarea por defecto\r\n});\r\n```\r\n## Complementos\r\nPuedes usar con Gulp gran número de complementos -de hecho más de 600-. Los encontrarás listados en la [página de complementos](http://gulpjs.com/plugins/) o buscando por `gulpplugin` en `npm`. Algunos complementos están etiquetados como \"gulpfriendly\" -amigables con Gulp-; no se trata de complementos, pero están diseñados para trabajar bien con Gulp. Ten en cuenta de que buscando directamente en `npm` no podrás ver si un complemento ha sido incluido en la lista negra (si mirás al pie de la página de complementos, verás que se ha incluido a muchos).\r\n\r\nMuchos de los complementos son bastante fáciles de usar, están bien documentados y se ejecutan de la misma manera (canalizando un flujo de objetos archivo hacia él). Estos modifican como de costumbre los archivos (aunque algunos, como los validadores, no lo hacen) y devuelven los nuevos archivos que han de pasarse al siguiente complemento.\r\n\r\nVamos a extendernos sobre la tarea `js` mencionada:\r\n```javascript\r\nvar gulp = require(\"gulp\"),\r\n  jshint = require(\"gulp-jshint\"),\r\n  uglify = require(\"gulp-uglify\"),\r\n  concat = require(\"gulp-concat\");\r\n\r\ngulp.task(\"js\", function () {\r\n  return gulp.src(\"js/*.js\")\r\n            .pipe(jshint())\r\n            .pipe(jshint.reporter(\"default\"))\r\n            .pipe(uglify())\r\n            .pipe(concat(\"app.js\"))\r\n            .pipe(gulp.dest(\"build));\r\n});\r\n```\r\nAquí usamos tres complementos: [`gulp-jshint`](https://github.com/wearefractal/gulp-jshint), [`gulp-uglify`](https://github.com/terinjokes/gulp-uglify) y [`gulp-concat`](https://github.com/wearefractal/gulp-concat). Podrás ver, en los archivos README de los complementos, que todos son bastante fáciles de usar; disponen de opciones, pero en general las opciones por defecto son suficientemente buenas.\r\n\r\nHabrás notado que llamamos al complemento JSHint dos veces. Esto es así, porque primero se ejecuta JSHint sobre los archivos, que solo añade una propiedad `jshint` a los objetos archivo sin devolver nada. Puedes leer dicha propiedad tu mismo o pasarla al `reporter` -informador- \"default\" de JSHint o a otro `reporter`, como [`jshint-stylish`](https://github.com/sindresorhus/jshint-stylish).\r\n\r\nLos otros dos complementos son más claros: la función `uglify()` minimiza el código y la función `concat(\"app.js\")` concatena todos los archivos en un único archivo `app.js`.\r\n\r\n## El complemento gulp-load-plugins\r\nUn módulo que encuentro especialmente útil es `gulp-load-plugins`, que carga automáticamente cualquier complemento Gulp de tu archivo `package.json` y los añade a un objeto. Su uso más básico es el siguiente:\r\n```javascript\r\nvar gulpLoadPlugins = require(\"gulp-load-plugins\"),\r\n    plugins = gulpLoadPlugins();\r\n```\r\nPuedes hacerlo todo en una sola línea, pero no me gustan las llamadas `require` inmediatas:\r\n```javascript\r\nvar plugins = require(\"gulp-load-plugins\")(); \r\n```\r\nDespués de ejecutar este código, el objeto `plugins` contiene todos los complementos, re-formateando sus nombres (por ejemplo, `gulp-ruby-sass` se cargaría como `plugins.rubySass`). Puedes usarlos después como si los hubieras requerido -`require(\"...\")- normalmente. Por ejemplo, nuestra anterior tarea `js` quedaría reducida a lo siguiente:\r\n```javascript\r\nvar gulp = require(\"gulp\"),\r\n  gulpLoadPlugins = require(\"gulp-load-plugins\"),\r\n  plugins = gulpLoadPlugins();\r\n  \r\ngulp.task(\"js\", function () {\r\n  return gulp.src(\"js/*.js\")\r\n  .pipe(plugins.jshint())\r\n  .pipe(plugins.jshint.reporter(\"default\"))\r\n  .pipe(plugins.uglify())\r\n  .pipe(plugins.concat(\"app.js\"))\r\n  .pipe(gulp.dest(\"build\"));\r\n});\r\n```\r\nEsto asume que tu archivo `package.json` es algo parecido a esto:\r\n```javascript\r\n{\r\n  \"devDependencies\": {\r\n    \"gulp-concat\": \"~2.2.0\",\r\n    \"gulp-uglify\": \"~0.2.1\",\r\n    \"gulp-jshint\": \"~1.5.1\",\r\n    \"gulp\": \"~3.5.6\"\r\n  }\r\n}\r\n```\r\nEn este ejemplo, no es realmente mucho más corto. De todas maneras, con archivos Gulp más grandes y más complicados, se reduce un montón de inclusiones a solo una o dos lineas.\r\n\r\nLa versión 0.4.0 de `gulp-load-plugins`, salida a principios de marzo (de 2014), añade la carga laxa de complementos -lazy plugin loading-, lo que mejora su rendimiento. Los complementos no se cargan hasta que no son llamados, lo que significa que no tienes que preocuparte de que los paquetes de `package.json` no usados afecten al rendimiento (aunque sería recomendable que los eliminaras). En otras palabras, si ejecutas una tarea que solo requiere dos complementos, esta no cargará todos los complementos que requieren las demás tareas.\r\n\r\n## Seguimiento de archivos\r\nGulp tiene la habilidad de hacer seguimiento de los cambios en archivos y luego ejecutar una o varias tareas cuando estos se producen. Esta característica es sorprendentemente útil (y, para mi, probablemente la más útil de Gulp). Puedes guardar tu archivo `.less`, y Gulp lo convertirá en otro `.css` y recargará el navegador sin que tu tengas que hacer nada.\r\n\r\nPara hacer seguimiento de uno o varios archivos usa la función `gulp.watch()`, que toma un `glob` -pegote- o un vector de estas  pseudo cadenas (lo mismo que `gulp.src()`) y también un vector de tareas a ejecutar o una función del tipo `callback` -retrollamada-.\r\n\r\nDigamos que tenemos una tarea de montaje que convierte nuestros archivos de plantillas en HTML, y nosotros queremos definir una tarea de seguimiento de cambios en los archivos de plantillas y que ejecute una tarea para convertirlos en HTML. Podemos usar la función `watch` como sigue:\r\n```javascript\r\ngulp.task(`watch`, function () {\r\n  gulp.watch(\"templates/*.tmpl.html\", [\"build\"])\r\n});\r\n```\r\nAhora, cuando modifiquemos un archivo de plantilla, la tarea `build` se ejecutará y se generará el HTML.\r\n\r\nTambién puedes pasar a la función `watch` -de seguimiento- una función del tipo `callback` -de ejecución subordinada-, en lugar de un vector de tareas. En este caso, la función subordinada recibirá un objeto del tipo evento que contendrá alguna información acerca del suceso que lanza la función subordinada -callback-:\r\n```javascript\r\ngulp.watch(\"templates/*.tmpl.html\", function (event) {\r\n  console.log(\"Event type: \" + event.type);\r\n  // added, changed o deleted\r\n  \r\n  console.log(\"Event path: \" + event.path);\r\n  // ruta del archivo modificado\r\n});\r\n```\r\n\r\nOtra característica interesante de `gulp.watch()` es que devuelve lo que llamamos un vigilante -watcher-. Usa al vigilante para observar sucesos adicionales o para incluir archivos en el seguimiento -`watch`-. Por ejemplo, para ejecutar una lista de tareas y llamar a una función subordinada -callback-, puedes añadir una escucha -listener- al evento `change` del `watcher` -vigilante- devuelto:\r\n```javascript\r\nvar watcher = gulp.watch(\"templates/*tmpl.html\", [\"build\"]);\r\nwatcher.on(\"change\", function (event) {\r\n  console.log(\"Event type: \" + event.type);\r\n  // added, change o deleted\r\n  \r\n  console.log(\"Event.path: \" + event.path);\r\n  // ruta del archivo modificado\r\n});\r\n```\r\n\r\nAdemás del evento `change`, puedes atender a cierto número de eventos:\r\n* `end`\r\n\r\nSe dispara cuando termina el `watcher` -vigilante- (lo que significa que las tareas y funciones subordinadas no volverán a ser llamadas más cuando cambien los archivos)\r\n* `error`\r\n\r\nSe dispara cuando sucede un error.\r\n* `ready`\r\n\r\nSe dispara cuando se localizan los ficheros y están siendo observados.\r\n* `nomatch`\r\n\r\nSe dispara cuando la pseudo-cadena -glob- no apunta a ningún archivo.\r\n\r\nEl objeto `watcher` también contiene algunos métodos que puedes llamar:\r\n* `watcher.end()`\r\n\r\nDetiene el objeto (de manera que ya no se llamará a ninguna tarea ni a ninguna función subordinada -callback-)\r\n* `watcher.files()`\r\n\r\nDevuelve una lista de archivos que están siendo observados por el objeto `watcher`\r\n* `watcher.add(glob)`\r\n\r\nAñade archivos que coinciden con la pseudo-cadena especificada al objeto `watcher` (también acepta una función subordinada -callback- como un segundo argumento)\r\n* `watcher.remove(filepath)`\r\n\r\nElimina un archivo concreto del objeto `watcher`\r\n\r\n## Recarga de cambios en el navegador\r\nPuedes hacer que Gulp recargue o actualice el navegador cuando tu o, para el caso, cualquier otra cosa, como una tarea Gulp, modifique un archivo. Hay dos maneras de hacerlo. La primera es usar el complemento `LiveReload`  y la segunda es usar `BrowserSync`.\r\n\r\n### LiveReload -recarga activa-\r\n[`LiveReload`](http://livereload.com/) se combina con extensiones del navegador (incluida [una extensión Chrome](https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei)) para recargar tu navegador cada vez que se detecta un cambio en el archivo. Puede usarse con la extensión [`gulp-watch`](https://www.npmjs.org/package/gulp-watch) o con el `gulp.watch()` incluido descrito antes. Aquí tienes un ejemplo del archivo README del [repositorio de `gulp-livereload`](https://github.com/vohof/gulp-livereload):\r\n\r\n```javascript\r\nvar gulp = require('gulp'),\r\n  less = require('gulp-less'),\r\n  livereload = require('gulp-livereload'),\r\n  watch = require('gulp-watch');\r\n\r\ngulp.task('less', function() {\r\n  gulp.src('less/*.less')\r\n    .pipe(watch())\r\n    .pipe(less())\r\n    .pipe(gulp.dest('css'))\r\n    .pipe(livereload());\r\n});\r\n```\r\nEste código vigila los cambios en todos los archivos que coincidan con `less/*.less`. Cuando se detecta un cambio, se generará el correspondiente (archivo) `css`, lo archivará y recargará el navegador.\r\n\r\n### BrowserSync -sincronización del navegador-\r\nHay una alternativa a `LifeReload`. [`BrowserSync`](http://browsersync.io/)es similar en cuanto que muestra los cambios en el navegador, pero dispone de numerosas funciones más.\r\n\r\nCuando modificas el código, `BrowserSync` o bien recarga la página, o, si se trata de `css`, inyecta el `css`, lo que significa que la página no necesita ser recargada. Esto resulta muy útil si tu página no es resistente a la recarga. Imagínate que estás trabajando en cuatro eventos click en tu aplicación de página única y que refrescando la página te encontrarías de nuevo en la página de inicio. Con `LiveReload` tendrías que hacer click cuatro veces cada vez que hicieras un cambio. `BrowserSync`, en cambio, simplemente inyectaría los cambios cuando modificaras el `css`, de manera que no necesitarías repetir los clicks. `BrowserSync` es mejor para probar tus diseños en varios navegadores.\r\n\r\n`BrowserSync`también sincroniza los clicks, las acciones de formulario y la posición del cursor entre (varios) navegadores. Puedes abrir unos cuantos navegadores en tu equipo de sobremesa y otro en tu móvil y luego moverte por tu página. Los enlaces se podrían activar en todos ellos, y según bajaras por la página, descenderías por ella en todos tus dispositivos (y además, normalmente con suavidad). Cuando introdujeras texto en un formulario, se introduciría en todas las ventanas. Y cuando no quisieras que tuviera este comportamiento podrías desactivarlo.\r\n\r\n`BrowserSyns` no requiere un complemento en el navegador, porque él se ocupa de servir tus archivos por ti (incluso a través de servidores intermedios -proxies- si son dinámicos) y sirve un archivo de órdenes -script- que abre una puerta -socket- entre el navegador y el servidor. Esto nunca me ha dado problemas en el pasado.\r\n\r\nNo existe en realidad un complemento para Gulp porque `BrowserSync` no manipula archivos, así que no podría funcionar como tal. Pero el módulo `BrowserSync`de `npm` puede ser llamado directamente desde Gulp. Lo primero es instalarlo via `npm`:\r\n```shell\r\nnpm install --save-dev browser-sync\r\n```\r\nDespués el siguiente archivo `gulpfile.js` iniciará `BrowserSync` y vigilará algunos archivos:\r\n```javascript\r\nvar gulp = require('gulp'),\r\n  browserSync = require('browser-sync');\r\n\r\ngulp.task('browser-sync', function () {\r\n  var files = [\r\n    'app/**/*.html',\r\n    'app/assets/css/**/*.css',\r\n    'app/assets/imgs/**/*.png',\r\n    'app/assets/js/**/*.js'\r\n    ];\r\n\r\n  browserSync.init(files, {\r\n    server: {\r\n      baseDir: './app'\r\n      }\r\n    });\r\n});\r\n```\r\nLa ejecución de `gulp browser-sync` vigilaría a los archivos coincidentes a la espera de cambios e iniciaría un servidor que serviría los archivos en el directorio `./app`.\r\n\r\nEl desarrollador de `BrowserSync` ha descrito en su repositorio de [BrowserSync + Gulp](https://github.com/shakyShane/gulp-browser-sync) algunas cosas más que puedes hacer (con este módulo).\r\n\r\n## ¿Por que Gulp?\r\nComo hemos mencionado, Gulp es una de las [varias herramientas](https://gist.github.com/callumacrae/9231589) de montaje disponibles en Javascript y también hay herramientas de montaje no escritas en Javascript, incluida Rake. ¿Por qué deberías usar Gulp?\r\n\r\nLas dos herramientas de montaje más populares en Javascript son Grunt y Gulp. Grunt era muy popular en 2013 y cambio completamente como desarrollaba la gente páginas webs. Hay miles de complementos disponibles para ello, para hacer de todo desde limpiar, minimizar y concatenar código, hasta instalar paquetes usando Bower e iniciar un servidor Express. Este planteamiento es muy diferente del de Gulp, que solo tiene complementos para realizar pequeñas tareas individuales con archivos. Puesto que las tareas solo son Javascript (a diferencia del gran objeto que usa Grunt), no necesitas un complemento; simplemente puedes iniciar un servidor de Express.\r\n\r\nLas tareas de Grunt tienden a estar sobre-configuradas, lo que requiere un objeto voluminoso que contendría propiedades de las que realmente no querrías tener que preocuparte, mientras que la misma tarea en Gulp puede suponer solo unas pocas lineas. Veamos un archivo simple `gruntfile.js` que define una tarea `css` para convertir nuestro LESS en CSS y después ejecutar [Autoprefixer ](https://github.com/ai/autoprefixer) sobre ello:\r\n```javascript\r\ngrunt.initConfig({\r\n  less: {\r\n    development: {\r\n      files: {\r\n        \"build/tmp/app.css\": \"assets/app.less\"\r\n        }\r\n      }\r\n    },\r\n\r\n  autoprefixer: {\r\n    options: {\r\n      browsers: ['last 2 version', 'ie 8', 'ie 9']\r\n      },\r\n      multiple_files: {\r\n        expand: true,\r\n        flatten: true,\r\n        src: 'build/tmp/app.css',\r\n        dest: 'build/'\r\n        }\r\n      }\r\n});\r\n\r\ngrunt.loadNpmTasks('grunt-contrib-less');\r\ngrunt.loadNpmTasks('grunt-autoprefixer');\r\n\r\ngrunt.registerTask('css', ['less', 'autoprefixer']);\r\n```\r\nCompáralo con el archivo `gulpfile.js` que hace lo mismo:\r\n```javascript\r\nvar gulp = require('gulp'),\r\n  less = require('gulp-less'),\r\n  autoprefix = require('gulp-autoprefixer');\r\n\r\ngulp.task('css', function () {\r\n  gulp.src('assets/app.less')\r\n      .pipe(less())\r\n      .pipe(autoprefix('last 2 version', 'ie 8', 'ie 9'))\r\n      .pipe(gulp.dest('build'));\r\n});\r\n```\r\nLa versión `gulpfile.js` es considerablemente más legible y pequeña.\r\n\r\nComo Grunt accede al sistema de archivos con muchísima más frecuencia que Gulp, Gulp es casi siempre más rápido que Grunt. Para un pequeño archivo LESS, el archivo `gulpfile.js` tardaría unos 6 milisegundos. El archivo `gruntfile.js` tarda 50 milisegundos -más de ocho veces más. Este es un pequeño ejemplo, pero con archivos más grandes, la cantidad de tiempo se incrementa significativamente.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}